unit DOBOTTYPE;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date:  2017/5/18                                            }
{    Generated Time: 21:38:49                                              }
{                                                                          }
{**************************************************************************}

interface
uses
{$IFDEF WIN32}
  Windows;
{$ELSE}
  Wintypes, WinProcs;
{$ENDIF}


{=> d:\dobot\dobotdemov2.0\dobotdemov2.0\dobotdll\precompiled\windows\x86\DOBOTTYPE.H <=}

{$IFNDEF DOBOTTYPE_H}
{$DEFINE DOBOTTYPE_H}

{$IFDEF _MSC_VER}
type
  uint8_t = Byte;
type
  int8_t = Char;
type
  uint16_t = Word;
type
  int16_t = SmallInt;
type
  uint32_t = Word;
type
  int32_t = Integer;
type
  uint64_t = UNSIGNED LONG LONG;
type
  int64_t = LONG LONG;
{$ELSE}
{$INCLUDE <stdint.h>}
{$ENDIF}

{+//******************************************************************************************************** }
{-** Data structures }
{=******************************************************************************************************** }

{+//******************************************************************************************************** }
{-** Common parts }
{=******************************************************************************************************** }
{ #pragma pack(push) }
{ #pragma pack(1) }

{+// }
{-* Real-time pose }
{= }
type
  tagPose = record
    x: Single;
    y: Single;
    z: Single;
    r: Single;
    jointAngle: Array[0..4-1] of Single;
  end {tagPose};

{+// }
{-* Kinematics parameters }
{= }
type
  tagKinematics = record
    velocity: Single;
    acceleration: Single;
  end {tagKinematics};

{+// }
{-* HOME related }
{= }
type
  tagHOMEParams = record
    x: Single;
    y: Single;
    z: Single;
    r: Single;
  end {tagHOMEParams};

type
  tagHOMECmd = record
    reserved: UINT32_T;
  end {tagHOMECmd};

{+// }
{-* Hand hold teach }
{= }
type
  tagHHTTrigMode = (
    TriggeredOnKeyReleased, 
    TriggeredOnPeriodicInterval  );

{+// }
{-* End effector }
{= }
type
  tagEndEffectorParams = record
    xBias: Single;
    yBias: Single;
    zBias: Single;
  end {tagEndEffectorParams};

{+// }
{-* Arm orientation }
{= }
type
  tagArmOrientation = (
    LeftyArmOrientation, 
    RightyArmOrientation );

{+// }
{-* JOG related }
{= }
type
  tagJOGJointParams = record
    velocity: Array[0..4-1] of Single;
    acceleration: Array[0..4-1] of Single;
  end {tagJOGJointParams};

type
  tagJOGCoordinateParams = record
    velocity: Array[0..4-1] of Single;
    acceleration: Array[0..4-1] of Single;
  end {tagJOGCoordinateParams};

type
  tagJOGCommonParams = record
    velocityRatio: Single;
    accelerationRatio: Single;
  end {tagJOGCommonParams};

type
  tagJOGCmd = (
    JogIdle, 
    JogAPPressed, 
    JogANPressed, 
    JogBPPressed, 
    JogBNPressed, 
    JogCPPressed, 
    JogCNPressed, 
    JogDPPressed, 
    JogDNPressed, 
    JogEPPressed, 
    JogENPressed  );

type
  tagJOGCmd = record
    isJoint: UINT8_T;
    cmd: UINT8_T;
  end {tagJOGCmd};

{+// }
{-* PTP related }
{= }
type
  tagPTPJointParams = record
    velocity: Array[0..4-1] of Single;
    acceleration: Array[0..4-1] of Single;
  end {tagPTPJointParams};

type
  tagPTPCoordinateParams = record
    xyzVelocity: Single;
    rVelocity: Single;
    xyzAcceleration: Single;
    rAcceleration: Single;
  end {tagPTPCoordinateParams};

type
  tagPTPJumpParams = record
    jumpHeight: Single;
    zLimit: Single;
  end {tagPTPJumpParams};

type
  tagPTPCommonParams = record
    velocityRatio: Single;
    accelerationRatio: Single;
  end {tagPTPCommonParams};

type
  PTPMode = (
    PTPJUMPXYZMode, 
    PTPMOVJXYZMode, 
    PTPMOVLXYZMode, 
    PTPJUMPANGLEMode, 
    PTPMOVJANGLEMode, 
    PTPMOVLANGLEMode, 
    PTPMOVJANGLEINCMode, 
    PTPMOVLXYZINCMode, 
    PTPMOVJXYZINCMode, 
    PTPJUMPMOVLXYZMode );

type
  tagPTPCmd = record
    ptpMode: UINT8_T;
    x: Single;
    y: Single;
    z: Single;
    r: Single;
  end {tagPTPCmd};

{+// }
{-* CP related }
{= }
type
  tagCPParams = record
    planAcc: Single;
    juncitionVel: Single;
        acc: Single;
    period: Single;
  end {tagCPParams};

type
  CPMode = (
    CPRelativeMode, 
    CPAbsoluteMode  );

type
  tagCPCmd = record
    cpMode: UINT8_T;
    x: Single;
    y: Single;
    z: Single;
        velocity: Single;
    power: Single;
  end {tagCPCmd};

{+// }
{-* ARC related }
{= }
type
  tagARCParams = record
    xyzVelocity: Single;
    rVelocity: Single;
    xyzAcceleration: Single;
    rAcceleration: Single;
  end {tagARCParams};

type
  tagARCCmd = record
        x: Single;
    y: Single;
    z: Single;
    r: Single;
  end {tagARCCmd};
type
  toPoint = record
    x: Single;
    y: Single;
    z: Single;
    r: Single;
  end {toPoint};

type
  tagWAITCmd = record
    timeout: UINT32_T;
  end {tagWAITCmd};

type
  tagTRIGMode = (
    TRIGInputIOMode, 
    TRIGADCMode  );

type
  tagTRIGInputIOCondition = (
    TRIGInputIOEqual, 
    TRIGInputIONotEqual  );

type
  tagTRIGADCCondition = (
    TRIGADCLT, 
    TRIGADCLE, 
    TRIGADCGE, 
    TRIGADCGT  );

type
  tagTRIGCmd = record
    address: UINT8_T;
    mode: UINT8_T;
    condition: UINT8_T;
    threshold: UINT16_T;
  end {tagTRIGCmd};

type
  tagIOFunction = (
    IOFunctionDummy, 
    IOFunctionDO, 
    IOFunctionPWM, 
    IOFunctionDI, 
    IOFunctionADC  );

type
  tagIOMultiplexing = record
    address: UINT8_T;
    multiplex: UINT8_T;
  end {tagIOMultiplexing};

type
  tagIODO = record
    address: UINT8_T;
    level: UINT8_T;
  end {tagIODO};

type
  tagIOPWM = record
    address: UINT8_T;
    frequency: Single;
    dutyCycle: Single;
  end {tagIOPWM};

type
  tagIODI = record
    address: UINT8_T;
    level: UINT8_T;
  end {tagIODI};

type
  tagIOADC = record
    address: UINT8_T;
    value: UINT16_T;
  end {tagIOADC};

type
  tagEMotor = record
    index: UINT8_T;
    isEnabled: UINT8_T;
    speed: Single;
  end {tagEMotor};

{+// }
{-* WIFI related }
{= }
type
  tagWIFIIPAddress = record
    dhcp: UINT8_T;
    addr: Array[0..4-1] of UINT8_T;
  end {tagWIFIIPAddress};

type
  tagWIFINetmask = record
    addr: Array[0..4-1] of UINT8_T;
  end {tagWIFINetmask};

type
  tagWIFIGateway = record
    addr: Array[0..4-1] of UINT8_T;
  end {tagWIFIGateway};

type
  tagWIFIDNS = record
    addr: Array[0..4-1] of UINT8_T;
  end {tagWIFIDNS};

type
  tagUserParams = record
    params: Array[0..8-1] of Single;
  end {tagUserParams};

{+//******************************************************************************************************** }
{-** API result }
{=******************************************************************************************************** }
type
  NewExit = (
    DobotConnect_NoError, 
    DobotConnect_NotFound, 
    DobotConnect_Occupied  );

type
  NewExit = (
    DobotCommunicate_NoError, 
    DobotCommunicate_BufferFull, 
    DobotCommunicate_Timeout, 
    DobotCommunicate_InvalidParams  );

{ #pragma pack(pop) }
{$ENDIF}

var
  DLLLoaded: Boolean { is DLL (dynamically) loaded already? }
    {$IFDEF WIN32} = False; {$ENDIF}

implementation

var
  SaveExit: pointer;
  DLLHandle: THandle;
{$IFNDEF MSDOS}
  ErrorMode: Integer;
{$ENDIF}

  procedure NewExit; far;
  begin
    ExitProc := SaveExit;
    FreeLibrary(DLLHandle)
  end {NewExit};

procedure LoadDLL;
begin
  if DLLLoaded then Exit;
{$IFNDEF MSDOS}
  ErrorMode := SetErrorMode($8000{SEM_NoOpenFileErrorBox});
{$ENDIF}
  DLLHandle := LoadLibrary('DOBOTTYPE.DLL');
  if DLLHandle >= 32 then
  begin
    DLLLoaded := True;
    SaveExit := ExitProc;
    ExitProc := @NewExit;
  end
  else
  begin
    DLLLoaded := False;
    { Error: DOBOTTYPE.DLL could not be loaded !! }
  end;
{$IFNDEF MSDOS}
  SetErrorMode(ErrorMode)
{$ENDIF}
end {LoadDLL};

begin
  LoadDLL;
end.
